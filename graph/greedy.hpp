/**
 * @brief 貪欲戦略に基づいたアルゴリズムを補助する関数の置き場
 * @date  2016/03/13~2017/01/03
 */



//****************************************
// インクルードガード
//****************************************

#ifndef __GREEDY_HPP__
#define __GREEDY_HPP__



//****************************************
// 必要なヘッダファイルのインクルード
//****************************************

#include "graph.hpp"



//****************************************
// 名前空間の始端
//****************************************

GRAPH_BEGIN



//****************************************
// 関数の宣言
//****************************************

/**
 * @brief  Primのアルゴリズムにおいては、最小全域木Aに属さないある孤立点(Aの辺と接続していない頂点)を連結する軽い辺を探し、
 *         Dijkstraのアルゴリズムにおいては、始点sからの最小の最短路推定値を持つ頂点u ∈ V - Sを選択する(集合Sに属さない"最も軽い"頂点を求める)
 *
 * @note   この関数が呼び出されるのはHeapを使わないPrimおよびDijkstraのアルゴリズムであり、
 *         ここでは、Heapを用いないでmin優先度付きキューを実現している
 *         そのようなアルゴリズムの記述においては、頂点の色において白は白および灰色、黒は黒としている
 *         よって、v.visitedがfalseのとき、v.colorは白または灰色であり、trueのとき、黒色である
 *
 * @param  const vertices_t& V 探索対象の頂点集合V
 * @param  index_t n           頂点集合Vの頂点数n
 * @return index_t u           条件を満たす頂点u(条件を満たす頂点が存在しない場合はnilを返す)
 */
static index_t extract_min(const vertices_t& V, index_t n)
{
    index_t  u = limits::nil;
    weight_t d = limits::inf; 
    for (index_t v = 0; v < n; ++v) {
        if (!V[v].visited && V[v].d < d) { d = V[v].d; u = v; }
    }
    return u;
}



//****************************************
// 名前空間の終端
//****************************************

GRAPH_END



#endif  // end of __GREEDY_HPP__

