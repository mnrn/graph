/**
 * @brief 幅優先探索に関する宣言を行う
 * @date  2016/02/12 ~ 2016/03/12
 */



//****************************************
// インクルードガード
//****************************************

#ifndef __BFS_HPP__
#define __BFS_HPP__



//****************************************
// 必要なヘッダファイルのインクルード
//****************************************

#include "../graph/graph.hpp"



//****************************************
// 名前空間の始端
//****************************************

GRAPH_BEGIN



//****************************************
// 関数の宣言
//****************************************

/**
 * @brief  幅優先探索を行います
 *
 * @note   幅優先探索(breadth-first-search)は最も単純なグラフ探索アルゴリズムの1つである
 *         グラフG=(V, E)を始点(source vertex)sが与えられたとき、幅優先探索はGの辺を組織的に探索して、
 *         sから到達可能なすべての頂点を"発見し"、すべての到達可能な頂点についてsからの距離(変数の最小値)を計算する
 *         さらに、sを根とし、到達可能な頂点をすべて含む「幅優先木」を構成する. sから到達可能な任意の頂点vについて、
 *         幅優先木におけるsからvへの単純道はGにおけるsからvへの「最短路」、すなわち最小数の辺を含む道に対応する
 *         有向グラフと無向グラフのどちらに対してもこのアルゴリズムは正しく動く
 *
 *         探索頂点と未探索頂点の境界を、境界の幅一杯にわたって一様に拡張することが幅優先探索という名前の由来である
 *         すなわち、このアルゴリズムはsから距離k+1にある頂点を発見する前に距離kにあるすべての頂点を発見する
 *
 * @note   手続きBFSはグラフを探索しながら幅優先木を構築する.この木はπ属性に対応する.形式的に言うと、
 *         sを始点とするグラフG=(V, E)に対して、Gの先行点部分グラフ(predecessor subgraph)をGπ=(Vπ, Eπ)として定義する.ただし、
 *           Vπ = { v ∈ V : v.π != NIL } ∪ {s}
 *         かつ
 *           Eπ = { (v.π, v) : v ∈ Vπ - {s} }
 *         である.Vπがsから到達可能な全頂点から構成され、すべてのv∈Vπに対して、sからvに至る唯一の単純道がGπに存在し、
 *         しかもこれがGにおけるsからvに至る最短路になっているとき、先行点部分グラフGπを幅優先木(breadth-first tree)と呼ぶ
 *         幅優先木は連結で|Eπ| = |Vπ| - 1を満たすから、実際に木である. Eπの辺を木辺(tree edge)と呼ぶ
 *
 * @note   BFSの総実行時間はΟ(V+E)である.したがって、幅優先探索はGの隣接リスト表現のサイズの線形時間で走る
 *
 * @param  const graph_t& G  グラフG
 * @param  index_t s  始点s
 * @return 幅優先木
 */
vertices_t bfs(const graph_t& G, index_t s);



/**
 * @brief BFSが幅優先木を計算した後でこの手続きを用いれば、sからvへの最短路上の頂点を印刷できる
 */
void printpath(const vertices_t& V, index_t s, index_t v);



//****************************************
// 名前空間の終端
//****************************************

GRAPH_END



#endif  // end of __BFS_HPP__

