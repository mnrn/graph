/**
 * @brief  全点対最短路問題におけるFloyd-Warshallアルゴリズムを扱う
 *
 * @note   今回のアルゴリズムは隣接行列表現を用いる
 *         便宜的に、頂点に番号0,1,...,|V|-1を降り、入力をn個の頂点を持つ有向グラフG = (V, E)の辺重みを表すn x nの行列Wとする
 *         すなわち、W = (wij)は
 *           wij = { 0                  i = jのとき
 *                   有向辺(i, j)の重み   i != jかつ(i, j) ∈ Eのとき
 *                   ∞                  i != jかつ(i, j) !∈ Eのとき }
 *         である. 入力となる辺は負辺を含んでもよいが、負閉路は含まないと仮定する(のちに、負閉路を検出する)
 *
 *         出力する表はn x n行列D = (dij)であり、各要素dijは頂点iからjへの最短路の重みである. すなわち、
 *         頂点iからjへの最短路重みをδ(i, j)とするとき、dij = δ(i, j)がアルゴリズム終了時に成立する
 *
 *         与えられた隣接行列上で全点対最短路問題を解くには、最短路の重みだけではなく先行点行列(predecessor matrix)Π = (πij)も求める必要がある
 *         ここでπijはi = jまたはiからjへの道がなければNILであり、それ以外の場合には、iからjへのある最短路上のjの先行点である
 *         先行点部分グラフGπが与えられた始点を根とする最短路木であったように、行列Πの第i行から誘導される部分グラフはiを根とする最短路木である
 *         各頂点i ∈ Vに対して、iに対するGの先行点部分グラフ(predecessor subgraph)をG(π,i) = (V(π,i), E(π,i))として定義する. ただし、
 *           V(π,i) = { j ∈ V : πij != NIL } ∪ { i }
 *         および
 *           E(π,i) = { (πij, j) : j ∈ V(π,i) - { i } }
 *         である
 *
 *         隣接行列に関していくつか約束をする. 最初に、入力グラフG = (V, E)はn個の頂点を持つ. したがって、n = |V|である
 *         第2に、行列を表すのに、W、L、Dのように大文字を用い、ここの要素はwij, lij, dijのように小文字に添字をつけて表す
 *         また、ある行列では、L^(m) = (lij^(m))やD^(m) = (dij^(m))のように、反復回数を表すのに肩に括弧付きの添字を用いることがある
 *         最後に、n x nの行列Aに対して、nの値は属性A.rowsに格納されている 
 *
 * @date   2016/02/21 ~ 2017/01/03
 */



//****************************************
// 必要なヘッダファイルのインクルード
//****************************************

#include "floyd_warshall.hpp"
#include <iostream>



//****************************************
// 名前空間の始端
//****************************************

GRAPH_BEGIN



//****************************************
// 関数の定義
//****************************************

/**
 * @brief  動的計画アルゴリズムであるFloyd-Warshallアルゴリズム
 *
 * @note   Floyd-Warshallアルゴリズムでは最短路の中間頂点を考える. ここで、単純道p = <v0,v1,...,vl>のv0とvl以外の頂点、
 *         すなわち、集合{ v1,v2,...,v(l-1) }の任意の頂点が中間(intermediate)頂点である
 *
 *         Floyd-Warshallアルゴリズムは以下の観察に基づいている. Gの頂点集合がV = { 0,1,...,n-1 }であるという仮定の下で、
 *         あるkに対して頂点の部分集合{ 0,1,...k }を考える. 任意の頂点対i,j ∈ Vに対して、iからjへの道で、そのすべての中間頂点が
 *         集合 { 0,1,...,k }に属するものをすべて考え、その中で最小の重みを持つ道をpとする. (道pは単純である)
 *
 *         Floyd-Warshallアルゴリズムは、道pと、中間頂点がすべて集合{ 0,1,...,k-1 }に属する(という条件の下での)iからjへの最短路との関係を解明する
 *         この関係はkが道pの中間頂点であるかどうかに依存する
 *
 *         * kが道pの中間頂点でなければ、pの中間頂点はすべて集合{ 0,1,...,k-1 }に属している. したがって、中間頂点がすべて集合{ 0,1,..,k-1 }に属する
 *           頂点iからjへの最短路は、中間頂点がすべて集合{ 0,1,...,k }に属するiからjへの最短路である
 *
 *         * kが道pの中間頂点ならば、pをi~(p1)~>k~(p2)~>jと分解する. p1は中間頂点がすべて集合{ 0,1,...,k }に属するiからjへの最短路である
 *           実際には、もう少し強い言明が成立する. 頂点kは道p1上の中間頂点ではないから、p1の中間頂点はすべて集合{ 0,1,...,k-1 }に属する.
 *           したがって、 p1は中間頂点がすべて集合{ 0,1,...,k-1 }に属するiからkへの最短路である
 *           同様に、p2は中間頂点がすべて集合{ 0,1,...,k-1 }に属する頂点kから頂点jへの最短路である
 *
 *         上の観察に基づいて、最短路の推定値を再帰的に定式化する. 中間頂点がすべて集合{ 0,...,k }に属する頂点iからjへの最短路の重みをdij^(k+1)とする
 *         k = -1のとき、-1より大きい番号を持つ中間頂点を通らない頂点iから頂点jへの道は中間頂点を1つも持たない. このような道は高々1本の辺しかもたないから、
 *         dij^(0) = wijである. よって、dij^(k+1)の再帰的な定義
 *           dij^(k+1) = { wij                            k = -1のとき
 *                       min(dij^(k), dik^(k) + djk^(k))  k >= 0のとき }
 *         を得る. 任意の道において、すべての中間頂点は集合{ 0,..,n-1 }に属するから、行列D^(n-1) = (dij^(n-1))が最終的な解を与える
 *         すなわち、すべてのi,j ∈ Vに対して、dij^(d) = δ(i, j)が成立する. 実際には、この場合を頂点0,1,...,k-1のみを使う場合に帰着させる
 *
 *         i,j,k = 0,1,...,n-1に対してdij^(k)を計算するからFloyd-WarshallアルゴリズムではΘ(n^3)の領域が必要であるが、
 *         前回の履歴のみを必要とするので、すべての肩添字を落としただけの手続きも正しく、Θ(n^2)の領域で十分である
 *
 * @note   3重のfor文における操作はΟ(1)時間で実行できるから、このアルゴリズムの実行時間はΘ(n^3)である
 *         このコードはタイトであって、複雑なデータ構造を含まず、Θ-記法に隠された定数は小さい
 *         したがって、Floyd-Warshallアルゴリズムは結構大きな入力グラフに対しても非常に実用的である
 *
 */
matrix_t floyd_warshall(const matrix_t& W)
{
    index_t n = W.size();  // n = W.rows
    matrix_t D(n, array_t(n, limits::inf));
    for (index_t i = 0; i < n; ++i) { std::copy(W[i].begin(), W[i].end(), D[i].begin()); D[i][i] = 0; }

    
    for (index_t k = 0; k < n; ++k) {
        for (index_t i = 0; i < n; ++i) {
            for (index_t j = 0; j < n; ++j) {
                // 任意の実数a != ∞に対して、a + ∞ = ∞ + a = ∞(また、a + (-∞) = (-∞) + a = (-∞))を仮定している
                if (D[i][k] != limits::inf && D[k][j] != limits::inf) {
                    D[i][j] = std::min(D[i][j], D[i][k] + D[k][j]);
                }
            }
        }
    }
    return D;
}



//****************************************
// 名前空間の終端
//****************************************

GRAPH_END




